import static org.gradle.internal.logging.text.StyledTextOutput.Style
import org.gradle.internal.logging.text.StyledTextOutputFactory
def out = services.get(StyledTextOutputFactory).create("gradle-color-output")

apply plugin: "org.hidetake.ssh"

def privateKey = file(System.properties['user.home'] + "/.ssh/id_rsa")

def deploy_remotes = [
        DEV_server: [
            env: ['dev'],
            app_home: '/app/fsap/fsap-ncl-batch',
            put_files: [
                    [from: tasks.findByName('bootJar'), into: "prepared_build/ncl-batch.jar", is_into_app_home: true],
            ],
            jar_name: 'ncl-batch.jar',
            is_jboss: false,
            //spring_config_filename: 'DEV.MGW1.config.yml',
            server: [
                identity: privateKey,
                host: '172.17.24.18',
                user: 'apuser'
            ]
        ],
        SIT_server: [
            env: ['sit'],
            app_home: '/home/jbossadm/war',
            put_files: [
                    [from: tasks.findByName('bootWar'), into: "prepared_build/bot-ncl-batch-app.war", is_into_app_home: true],
            ],
            jar_name: 'bot-ncl-batch-app.war',
            is_jboss: true,
            //spring_config_filename: 'DEV.OGW1.config.yml',
            server: [
                identity: privateKey,
                host: '10.1.9.211',
                user: 'jbossadm'
            ]
        ]
]

task sshInfo {
    doFirst {
        logger.quiet "\n\n\u001b[32mLoading private key for deploy at location ${privateKey} \u001B[0m\n\n"
    }
}

ssh.settings {
    dryRun = project.hasProperty('dryRun')
    //pty = true
    encoding = 'UTF-8'
    knownHosts = allowAnyHosts
    timeoutSec = 600
    jschLog = true
}

task put_files {
    doLast {
        def system_prop = System.getProperties()
        def env = system_prop.get('env', 'sit')
        def exclude_remotes = system_prop.get('exclude_remotes', '')
        def include_remotes = system_prop.get('include_remotes', '')
        if (deploy.enabled) {
            deploy_remotes.findAll(x ->
                    x.value.env.contains(env)
                            && !exclude_remotes.split(',').contains(x.key)
                            && (include_remotes.equals('') || include_remotes.split(',').contains(x.key))
            ).each {
                def server_name = it.getKey()
                def server_config = it.getValue()
                ssh.run {
                    session(server_config.server) {
                        out.withStyle(Style.Info).println "\n\n\t"
                        execute """
                            set -e
                            mkdir -p ${server_config.app_home}/prepared_build
                        """, logging: 'stdout'
                        server_config.put_files.each {
                            def put_from = it.from
                            def put_into = it.into
                            if (it.is_into_app_home) put_into = "${server_config.app_home}/$put_into"
                            if (put_from instanceof Task) put_from = put_from.archiveFile.get().asFile.path
                            out.withStyle(Style.Info).println "put file to remote $server_name: $put_from --> $put_into"
                            put from: put_from, into: put_into, logging: 'stdout'
                        }
                        out.withStyle(Style.Info).println "\n\n"
                    }
                }
            }
        }
    }
}

task remote_start {
    doLast {
        def system_prop = System.getProperties()
        def env = system_prop.get('env', 'sit')
        def exclude_remotes = system_prop.get('exclude_remotes', '')
        def include_remotes = system_prop.get('include_remotes', '')
        if (deploy.enabled) {
            deploy_remotes.findAll(x ->
                    x.value.env.contains(env)
                            && !exclude_remotes.split(',').contains(x.key)
                            && (include_remotes.equals('') || include_remotes.split(',').contains(x.key))
            ).each {
                def server_name = it.getKey()
                def server_config = it.getValue()
                if (server_config.is_jboss) {
                    ssh.run {
                        session(server_config.server) {
                            out.withStyle(Style.Info).println "\n\n\tstart server on remote $server_name \n\n"
                            execute """
                                set -e
                                cd $server_config.app_home
                                cp $server_config.app_home/prepared_build/* $server_config.app_home
                                chmod 775 $server_config.jar_name
                                /jboss/bin/jboss-cli.sh --connect --command="deploy $server_config.app_home/$server_config.jar_name --force"
                            """, logging: 'stdout'
                        }
                    }
                } else {
                    ssh.run {
                        session(server_config.server) {
                            out.withStyle(Style.Info).println "\n\n\tstart server on remote $server_name \n\n"
                            execute """
                                set -e
                                cd $server_config.app_home
                                sh ./stop.sh
                                cp $server_config.app_home/prepared_build/* $server_config.app_home
                                sh ./run.sh
                            """, logging: 'stdout'
                        }
                    }
                }
            }
        }
    }
}

task deploy {
    dependsOn assemble, put_files, remote_start
    put_files.mustRunAfter assemble
    remote_start.mustRunAfter put_files
}

